---
title: "Multi-Period Multi-Objective Portfolio Optimization in Agricultural Commodity Futures"
subtitle: "Evolutionary Algorithms with Dynamic Rebalancing and Transaction Costs"
format:
  html:
    toc: true
    toc-depth: 3
    toc-location: left
    number-sections: true
    theme: cosmo
    code-fold: true
    code-tools: true
    css: styles.css
    self-contained: false
author:
  - name: Rodrigo Hermont Ozon
    email: rodrigo.ozon@fae.edu
    affiliation: "FAE Business School and PUCPR"
  - name: Gilberto Reynoso-Meza
    email: gilberto.reynoso@pucpr.br
    affiliation: "PUCPR"
date: today
execute:
  warning: false
  message: false
  echo: true
  error: false
  cache: false
  freeze: auto
---

```{r}
#| label: setup-packages
#| include: false

# Load required R packages
suppressPackageStartupMessages({
  library(tidyverse)           # Data manipulation and visualization
  library(quantmod)            # Financial data acquisition
  library(PerformanceAnalytics) # Portfolio performance metrics
  library(ggplot2)             # Advanced plotting
  library(plotly)              # Interactive plots - CRITICAL FOR GITHUB PAGES
  library(knitr)               # Document generation
  library(kableExtra)          # Enhanced tables
  library(moments)             # Statistical moments
  library(patchwork)           # Combine plots
  library(mco)                 # Multi-criteria optimization (NSGA-II)
  library(DEoptim)             # Differential Evolution optimization
  library(RcppDE)              # Faster DE implementation
  library(gridExtra)           # Grid layouts for plots
  library(scales)              # Scaling functions for visualization
})

# Resolve function conflicts
conflicted::conflict_prefer("select", "dplyr")
conflicted::conflict_prefer("filter", "dplyr")
conflicted::conflict_prefer("lag", "dplyr")
conflicted::conflict_prefer("first", "dplyr")
conflicted::conflict_prefer("last", "dplyr")
conflicted::conflict_prefer("skewness", "moments")
conflicted::conflict_prefer("kurtosis", "moments")
conflicted::conflict_prefer("DEoptim.control", "DEoptim")
conflicted::conflict_prefer("DEoptim", "DEoptim")
conflicted::conflict_prefer("layout", "plotly")  # NEW: plotly layout

# Set options
options(scipen = 999)
theme_set(theme_minimal(base_size = 11))
set.seed(42)  # For reproducibility
```

# Introduction {#sec-introduction}

Agricultural commodity futures markets represent a critical component of global food security and economic stability, characterized by persistent volatility, non-normal return distributions, and complex interdependencies [@Gilbert2010]. Traditional portfolio optimization approaches, predominantly single-period mean-variance frameworks, fail to capture the dynamic nature of these markets where sequential rebalancing decisions interact with transaction costs, liquidity constraints, and evolving market conditions [@Markowitz1952].

This research addresses a fundamental gap in agricultural commodity portfolio management by developing a comprehensive **multi-period multi-objective optimization framework** that explicitly accounts for:

1. **Multiple Conflicting Objectives**: Simultaneously optimizing expected return, risk (measured by Conditional Value-at-Risk), portfolio concentration (Herfindahl index), liquidity, and transaction costs
2. **Temporal Dependencies**: Modeling the intertemporal structure of portfolio decisions through monthly rebalancing with realistic transaction costs
3. **Algorithmic Diversity**: Comparing multiple state-of-the-art evolutionary algorithms (NSGA-II, NSGA-III, DEOptim, MOEA/D) in agricultural commodity contexts

## Research Motivation {#sec-motivation}

The motivation for this work stems from three critical observations:

**First**, agricultural commodity portfolios face unique challenges absent in traditional equity portfolios: seasonality patterns, weather dependencies, geopolitical supply shocks, and biofuel policy impacts [@FAO2025]. These factors create regime-dependent volatility and correlation structures that require sophisticated optimization frameworks.

**Second**, real-world portfolio management is inherently multi-period: investors make sequential allocation decisions, incur transaction costs when rebalancing, and face constraints on turnover and liquidity [@Sutton2018]. Single-period optimization ignores these critical features, potentially leading to impractical recommendations with excessive turnover.

**Third**, modern investors face multiple objectives beyond simple mean-variance trade-offs: diversification requirements, liquidity needs, sustainability mandates, and operational constraints [@Deb2002]. Multi-objective evolutionary algorithms provide a natural framework for exploring these trade-offs through Pareto-efficient frontiers.

## Research Objectives {#sec-objectives}

This study pursues four specific objectives:

1. **Multi-Period Framework Development**: Construct a dynamic portfolio optimization model that explicitly incorporates monthly rebalancing decisions, transaction costs (bid-ask spreads and commissions), and temporal linkages between periods

2. **Multi-Objective Formulation**: Design an optimization framework with five competing objectives:
   - Expected return maximization
   - Risk minimization (CVaR at 95% confidence)
   - Portfolio concentration reduction (Herfindahl index)
   - Liquidity enhancement
   - Transaction cost minimization

3. **Algorithmic Comparison**: Empirically evaluate the performance of four evolutionary algorithms (NSGA-II, NSGA-III, DEOptim, MOEA/D) in agricultural commodity portfolio contexts, identifying strengths and weaknesses

4. **Practical Implementation**: Develop reproducible R code for practitioners to apply these methodologies to their own commodity portfolios, with explicit treatment of data aggregation (daily to monthly), realistic constraints, and backtesting procedures

## Contribution to the Literature {#sec-contribution}

This research makes three primary contributions:

**Methodological Innovation**: We integrate multi-period decision-making with multi-objective optimization specifically for agricultural commodities, a combination rarely explored in existing literature. Most studies focus either on single-period MOO or multi-period single-objective optimization, but not both [@Mwamba2023].

**Algorithmic Insights**: By comparing four distinct evolutionary algorithms on the same problem, we provide practical guidance on algorithm selection for commodity portfolio managers. Previous studies typically employ a single algorithm without comparative analysis [@Gao2024].

**Reproducibility and Transparency**: We provide complete, documented R code and real data, facilitating replication and extension by researchers and practitioners. This addresses the reproducibility crisis in computational finance [@Espiga2024].

# Theoretical Framework {#sec-theory}

## Multi-Period Portfolio Optimization {#sec-multiperiod}

Consider an investor managing a portfolio of $N$ agricultural commodity futures over $T$ discrete time periods (months). At each period $t \in \{1, 2, \ldots, T\}$, the investor observes:

- **Portfolio weights**: $\mathbf{w}_t = (w_{1,t}, w_{2,t}, \ldots, w_{N,t})$ where $\sum_{i=1}^N w_{i,t} = 1$ and $w_{i,t} \geq 0$ (long-only constraint)
- **Asset returns**: $\mathbf{r}_t = (r_{1,t}, r_{2,t}, \ldots, r_{N,t})$ representing log-returns from period $t-1$ to $t$
- **Transaction costs**: $c_t = \kappa \sum_{i=1}^N |w_{i,t} - w_{i,t-1}^{\text{drift}}|$ where $\kappa$ is the proportional transaction cost rate and $w_{i,t-1}^{\text{drift}}$ represents the drifted weight from period $t-1$

The **portfolio return** at period $t$ is:
$$
R_t = \sum_{i=1}^N w_{i,t} r_{i,t} - c_t
$$

Over a multi-period horizon, the **cumulative return** becomes:
$$
R_{\text{cumulative}} = \prod_{t=1}^T (1 + R_t) - 1
$$

[Rest of theoretical content remains the same...]

# Data and Methodology {#sec-data}

## Data Collection {#sec-data-collection}

We utilize daily futures price data for seven major Brazilian agricultural commodities from 2019 to present:

```{r}
#| label: data-loading
#| cache: true
#| message: false

# Define commodity tickers for B3 (Brazilian futures)
commodity_tickers <- c(
  "ZC=F",    # Corn
  "ZS=F",    # Soybeans
  "ZW=F",    # Wheat
  "ZSM=F",   # Soybean Meal
  "ZL=F",    # Soybean Oil
  "CT=F",    # Cotton
  "CC=F"     # Coffee
)

commodity_names <- c(
  "Corn", "Soybeans", "Wheat", "Soybean_Meal", 
  "Soybean_Oil", "Cotton", "Coffee"
)

# Download historical prices using quantmod
portfolioPrices <- NULL
for (i in seq_along(commodity_tickers)) {
  ticker <- commodity_tickers[i]
  name <- commodity_names[i]
  
  tryCatch({
    prices <- getSymbols(ticker, src = "yahoo", 
                         from = "2019-01-01", 
                         auto.assign = FALSE)
    prices <- Cl(prices)  # Extract closing prices
    colnames(prices) <- name
    
    if (is.null(portfolioPrices)) {
      portfolioPrices <- prices
    } else {
      portfolioPrices <- merge(portfolioPrices, prices)
    }
  }, error = function(e) {
    message(paste("Error downloading", ticker, ":", e$message))
  })
}

# Remove missing values
portfolioPrices <- na.omit(portfolioPrices)

# Display summary statistics
summary(portfolioPrices) %>%
  kable(caption = "Summary Statistics of Daily Commodity Futures Prices (2019-Present)",
        digits = 2) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

### Price Visualization {#sec-price-viz}

```{r}
#| label: price-visualization
#| fig.width: 12
#| fig.height: 8
#| fig.cap: "Historical Price Evolution of Agricultural Commodity Futures (2019-Present)"

# Convert to data frame for plotting
price_df <- portfolioPrices %>%
  as.data.frame() %>%
  rownames_to_column("Date") %>%
  mutate(Date = as.Date(Date)) %>%
  pivot_longer(
    cols = -Date,
    names_to = "Commodity",
    values_to = "Price"
  )

# Create normalized price plot with ggplot2
p_prices <- price_df %>%
  group_by(Commodity) %>%
  mutate(Normalized_Price = Price / dplyr::first(Price) * 100) %>%
  ggplot(aes(x = Date, y = Normalized_Price, color = Commodity)) +
  geom_line(linewidth = 0.8, alpha = 0.8) +
  scale_color_brewer(palette = "Set2") +
  labs(
    title = "Normalized Commodity Futures Prices",
    subtitle = "Base = 100 at 2019-01-01",
    x = "Date",
    y = "Normalized Price",
    color = "Commodity"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )

# Convert to interactive plotly
ggplotly(p_prices, tooltip = c("x", "y", "color")) %>%
  layout(
    hovermode = "x unified",
    legend = list(
      orientation = "h",
      x = 0.5,
      xanchor = "center",
      y = -0.2
    )
  )
```

## Return Calculation and Monthly Aggregation {#sec-returns}

We calculate daily log-returns and aggregate them to monthly returns using **22 trading days per month**:

```{r}
#| label: return-calculation
#| cache: true

# Calculate daily log-returns
daily_returns <- na.omit(Return.calculate(portfolioPrices, method = "log"))

# Function to aggregate daily returns to monthly (22-day periods)
aggregate_to_monthly <- function(daily_returns, window = 22) {
  n_days <- nrow(daily_returns)
  n_periods <- floor(n_days / window)
  
  monthly_returns <- matrix(NA, nrow = n_periods, ncol = ncol(daily_returns))
  colnames(monthly_returns) <- colnames(daily_returns)
  
  for (i in 1:n_periods) {
    start_idx <- (i - 1) * window + 1
    end_idx <- i * window
    
    # Sum log-returns to get monthly log-return
    monthly_returns[i, ] <- colSums(daily_returns[start_idx:end_idx, ], na.rm = TRUE)
  }
  
  # Convert to xts object
  dates <- index(daily_returns)[seq(window, n_periods * window, by = window)]
  monthly_returns <- xts(monthly_returns, order.by = dates)
  
  return(monthly_returns)
}

# Aggregate to monthly returns
monthly_returns <- aggregate_to_monthly(daily_returns, window = 22)

# Display summary statistics
summary(monthly_returns * 100) %>%  # Convert to percentage
  kable(caption = "Summary Statistics of Monthly Returns (%) - 22-Day Aggregation",
        digits = 2) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

## Return Distribution Analysis {#sec-return-distribution}

```{r}
#| label: return-distributions
#| fig.width: 14
#| fig.height: 10
#| fig.cap: "Monthly Return Distributions (Histograms and Q-Q Plots)"

# Prepare data for histograms
return_df <- monthly_returns %>%
  as.data.frame() %>%
  rownames_to_column("Date") %>%
  pivot_longer(
    cols = -Date,
    names_to = "Commodity",
    values_to = "Return"
  ) %>%
  mutate(Return = Return * 100)  # Convert to percentage

# Create histogram plots with ggplot2
p_hist <- ggplot(return_df, aes(x = Return, fill = Commodity)) +
  geom_histogram(bins = 30, alpha = 0.7, color = "black") +
  facet_wrap(~ Commodity, scales = "free", ncol = 4) +
  scale_fill_brewer(palette = "Set3") +
  labs(
    title = "Monthly Return Distributions",
    x = "Return (%)",
    y = "Frequency"
  ) +
  theme_minimal(base_size = 10) +
  theme(
    legend.position = "none",
    plot.title = element_text(face = "bold", hjust = 0.5)
  )

# Convert to interactive plotly
ggplotly(p_hist) %>%
  layout(
    title = list(
      text = "<b>Monthly Return Distributions</b>",
      x = 0.5,
      xanchor = "center"
    ),
    showlegend = FALSE,
    hovermode = "closest"
  )

# Q-Q plots remain as base R (they work well as static images)
par(mfrow = c(2, 4), mar = c(4, 4, 2, 1))
for (i in 1:ncol(monthly_returns)) {
  qqnorm(monthly_returns[, i], 
         main = paste("Q-Q Plot:", colnames(monthly_returns)[i]),
         cex.main = 0.9)
  qqline(monthly_returns[, i], col = "red", lwd = 2)
}
```

## Correlation Structure {#sec-correlation}

```{r}
#| label: correlation-analysis
#| fig.width: 10
#| fig.height: 8
#| fig.cap: "Correlation Matrix of Monthly Commodity Returns"

# Calculate correlation matrix
cor_matrix <- cor(monthly_returns, use = "complete.obs")

# Create heatmap using ggplot2
cor_df <- cor_matrix %>%
  as.data.frame() %>%
  rownames_to_column("Commodity1") %>%
  pivot_longer(
    cols = -Commodity1,
    names_to = "Commodity2",
    values_to = "Correlation"
  )

p_corr <- ggplot(cor_df, aes(x = Commodity1, y = Commodity2, fill = Correlation)) +
  geom_tile(color = "white") +
  geom_text(aes(label = sprintf("%.2f", Correlation)), size = 3) +
  scale_fill_gradient2(
    low = "#d73027",
    mid = "white",
    high = "#1a9850",
    midpoint = 0,
    limits = c(-1, 1),
    name = "Correlation"
  ) +
  labs(
    title = "Correlation Matrix of Agricultural Commodity Returns",
    subtitle = "Monthly Returns (22-Day Aggregation)",
    x = "",
    y = ""
  ) +
  theme_minimal(base_size = 11) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )

# Convert to interactive plotly
ggplotly(p_corr, tooltip = c("x", "y", "fill", "text")) %>%
  layout(
    title = list(
      text = "<b>Correlation Matrix of Agricultural Commodity Returns</b><br><sub>Monthly Returns (22-Day Aggregation)</sub>",
      x = 0.5,
      xanchor = "center"
    ),
    xaxis = list(tickangle = 45),
    hovermode = "closest"
  )
```

# Multi-Objective Portfolio Optimization {#sec-optimization}

## Objective Function Implementation {#sec-obj-functions}

We implement five objective functions as described in the theoretical framework:

```{r}
#| label: objective-functions

# Function to calculate portfolio objectives
calculate_objectives <- function(weights, returns, 
                                  transaction_cost_rate = 0.002,
                                  prev_weights = NULL) {
  
  # Ensure weights sum to 1
  weights <- weights / sum(weights)
  
  # 1. Expected Return (to be maximized)
  expected_return <- sum(weights * colMeans(returns))
  
  # 2. CVaR at 95% confidence (to be minimized)
  portfolio_returns <- returns %*% weights
  VaR_95 <- quantile(portfolio_returns, 0.05)
  CVaR_95 <- mean(portfolio_returns[portfolio_returns <= VaR_95])
  CVaR_95 <- abs(CVaR_95)  # Take absolute value
  
  # 3. Herfindahl-Hirschman Index (HHI) - concentration (to be minimized)
  HHI <- sum(weights^2)
  
  # 4. Liquidity (Shannon entropy) - to be maximized
  weights_nonzero <- weights[weights > 1e-8]
  liquidity <- -sum(weights_nonzero * log(weights_nonzero))
  
  # 5. Transaction costs (to be minimized)
  if (!is.null(prev_weights)) {
    transaction_cost <- transaction_cost_rate * sum(abs(weights - prev_weights))
  } else {
    transaction_cost <- 0
  }
  
  # Return all objectives
  # Note: For minimization in MOO, use negative values for max objectives
  return(c(
    Return = -expected_return,        # Negative for minimization
    CVaR = CVaR_95,
    HHI = HHI,
    Liquidity = -liquidity,           # Negative for minimization
    TransactionCost = transaction_cost
  ))
}
```

## NSGA-II Implementation {#sec-nsga2-impl}

We employ the Non-dominated Sorting Genetic Algorithm II (NSGA-II) to find the Pareto-optimal frontier:

```{r}
#| label: nsga2-optimization
#| cache: true

library(mco)

# Define the multi-objective function for NSGA-II
moo_function <- function(x) {
  calculate_objectives(x, monthly_returns)
}

# Set NSGA-II parameters
n_vars <- ncol(monthly_returns)
lower_bounds <- rep(0, n_vars)      # No short selling
upper_bounds <- rep(1, n_vars)      # Maximum 100% in any asset

# Run NSGA-II
set.seed(42)
nsga2_result <- nsga2(
  fn = moo_function,
  idim = n_vars,              # Number of decision variables
  odim = 5,                   # Number of objectives
  lower.bounds = lower_bounds,
  upper.bounds = upper_bounds,
  popsize = 100,              # Population size
  generations = 200,          # Number of generations
  cprob = 0.9,                # Crossover probability
  cdist = 10,                 # Crossover distribution index
  mprob = 1/n_vars,           # Mutation probability
  mdist = 20                  # Mutation distribution index
)

# Extract Pareto front solutions
pareto_front <- nsga2_result$value
pareto_weights <- nsga2_result$par

# Normalize all weight vectors to sum to 1
pareto_weights <- t(apply(pareto_weights, 1, function(w) w / sum(w)))

# Convert to data frame for plotting
pareto_df <- data.frame(
  Return = -pareto_front[, 1] * 100,  # Convert back to percentage
  CVaR = pareto_front[, 2] * 100,
  HHI = pareto_front[, 3],
  Liquidity = -pareto_front[, 4],
  TransactionCost = pareto_front[, 5] * 100
)

# Display summary of Pareto front
summary(pareto_df) %>%
  kable(caption = "Summary Statistics of NSGA-II Pareto Front Solutions",
        digits = 3) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

### NSGA-II Pareto Front Visualization {#sec-nsga2-viz}

```{r}
#| label: nsga2-pareto-front
#| fig.width: 14
#| fig.height: 10
#| fig.cap: "NSGA-II Pareto Front: 2D Projections"

# Create 2D projections of Pareto front with ggplot2
p1 <- ggplot(pareto_df, aes(x = CVaR, y = Return)) +
  geom_point(alpha = 0.6, size = 2, color = "#003d7a") +
  labs(
    title = "Return vs. Risk (CVaR)",
    x = "CVaR (%, minimize)",
    y = "Expected Return (%, maximize)"
  ) +
  theme_minimal(base_size = 10)

p2 <- ggplot(pareto_df, aes(x = HHI, y = Return)) +
  geom_point(alpha = 0.6, size = 2, color = "#28a745") +
  labs(
    title = "Return vs. Concentration (HHI)",
    x = "HHI (minimize)",
    y = "Expected Return (%, maximize)"
  ) +
  theme_minimal(base_size = 10)

p3 <- ggplot(pareto_df, aes(x = Liquidity, y = Return)) +
  geom_point(alpha = 0.6, size = 2, color = "#ffc107") +
  labs(
    title = "Return vs. Liquidity",
    x = "Liquidity (maximize)",
    y = "Expected Return (%, maximize)"
  ) +
  theme_minimal(base_size = 10)

p4 <- ggplot(pareto_df, aes(x = TransactionCost, y = Return)) +
  geom_point(alpha = 0.6, size = 2, color = "#ff6b35") +
  labs(
    title = "Return vs. Transaction Cost",
    x = "Transaction Cost (%, minimize)",
    y = "Expected Return (%, maximize)"
  ) +
  theme_minimal(base_size = 10)

# Convert each to plotly
p1_plotly <- ggplotly(p1, tooltip = c("x", "y")) %>%
  layout(title = list(text = "<b>Return vs. Risk (CVaR)</b>"))

p2_plotly <- ggplotly(p2, tooltip = c("x", "y")) %>%
  layout(title = list(text = "<b>Return vs. Concentration (HHI)</b>"))

p3_plotly <- ggplotly(p3, tooltip = c("x", "y")) %>%
  layout(title = list(text = "<b>Return vs. Liquidity</b>"))

p4_plotly <- ggplotly(p4, tooltip = c("x", "y")) %>%
  layout(title = list(text = "<b>Return vs. Transaction Cost</b>"))

# Create subplot layout
subplot(
  p1_plotly, p2_plotly,
  p3_plotly, p4_plotly,
  nrows = 2,
  shareX = FALSE,
  shareY = TRUE,
  titleX = TRUE,
  titleY = TRUE
) %>%
  layout(
    title = list(
      text = "<b>NSGA-II Pareto Front: 2D Projections</b>",
      x = 0.5,
      xanchor = "center",
      y = 0.98
    ),
    showlegend = FALSE,
    hovermode = "closest"
  )
```

## DEOptim Implementation {#sec-deoptim-impl}

For DEOptim, we use a weighted sum scalarization approach to convert the multi-objective problem into a single-objective problem:

```{r}
#| label: deoptim-optimization
#| cache: true

library(DEoptim)

# Scalarization function: weighted sum
# User can adjust weights to explore different trade-offs
objective_weights <- c(
  Return = 0.4,          # 40% weight on return maximization
  CVaR = 0.3,            # 30% weight on risk minimization
  HHI = 0.15,            # 15% weight on diversification
  Liquidity = 0.10,      # 10% weight on liquidity
  TransactionCost = 0.05 # 5% weight on transaction costs
)

# Scalarized objective function
scalarized_objective <- function(x) {
  obj_values <- calculate_objectives(x, monthly_returns)
  
  # Normalize objectives to [0, 1] range (approximate)
  obj_normalized <- c(
    abs(obj_values["Return"]) / 0.05,      # Assume max return ~5%
    obj_values["CVaR"] / 0.10,             # Assume max CVaR ~10%
    obj_values["HHI"] / 0.3,               # HHI range [0, 1]
    abs(obj_values["Liquidity"]) / 2.5,    # Shannon entropy range
    obj_values["TransactionCost"] / 0.01   # Assume max TC ~1%
  )
  
  # Weighted sum
  return(sum(objective_weights * obj_normalized))
}

# Run DEOptim
set.seed(42)
deoptim_result <- DEoptim(
  fn = scalarized_objective,
  lower = lower_bounds,
  upper = upper_bounds,
  control = DEoptim.control(
    NP = 50,              # Population size
    itermax = 200,        # Maximum iterations
    F = 0.8,              # Differential weight
    CR = 0.9,             # Crossover probability
    trace = FALSE
  )
)

# Extract optimal solution
optimal_weights_de <- deoptim_result$optim$bestmem / sum(deoptim_result$optim$bestmem)
optimal_objectives_de <- calculate_objectives(optimal_weights_de, monthly_returns)

# Display results
cat("\n=== DEOptim Optimal Portfolio ===\n")
cat("Weights:\n")
print(round(optimal_weights_de, 4))
cat("\nObjective Values:\n")
cat(sprintf("Expected Return: %.4f%%\n", -optimal_objectives_de["Return"] * 100))
cat(sprintf("CVaR (95%%): %.4f%%\n", optimal_objectives_de["CVaR"] * 100))
cat(sprintf("HHI: %.4f\n", optimal_objectives_de["HHI"]))
cat(sprintf("Liquidity: %.4f\n", -optimal_objectives_de["Liquidity"]))
cat(sprintf("Transaction Cost: %.4f%%\n", optimal_objectives_de["TransactionCost"] * 100))
```

### DEOptim Convergence Plot {#sec-deoptim-conv}

```{r}
#| label: deoptim-convergence
#| fig.width: 10
#| fig.height: 6
#| fig.cap: "DEOptim Convergence History"

# Extract convergence history
convergence_df <- data.frame(
  Iteration = 1:length(deoptim_result$member$bestvalit),
  BestValue = deoptim_result$member$bestvalit,
  MeanValue = deoptim_result$member$bestvalit  # Simplified
)

p_conv <- ggplot(convergence_df, aes(x = Iteration)) +
  geom_line(aes(y = BestValue, color = "Best Value"), linewidth = 1) +
  scale_color_manual(values = c("Best Value" = "#003d7a")) +
  labs(
    title = "DEOptim Convergence History",
    subtitle = "Scalarized Objective Function Value",
    x = "Iteration",
    y = "Objective Function Value",
    color = ""
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )

# Convert to interactive plotly
ggplotly(p_conv, tooltip = c("x", "y")) %>%
  layout(
    title = list(
      text = "<b>DEOptim Convergence History</b><br><sub>Scalarized Objective Function Value</sub>",
      x = 0.5,
      xanchor = "center"
    ),
    hovermode = "x unified",
    legend = list(
      orientation = "h",
      x = 0.5,
      xanchor = "center",
      y = -0.15
    )
  )
```

## Portfolio Weight Comparison {#sec-weight-comparison}

```{r}
#| label: weight-comparison-viz
#| fig.width: 12
#| fig.height: 8
#| fig.cap: "Portfolio Weight Allocations Across Optimization Strategies"

# Select representative solutions from NSGA-II Pareto front
nsga2_balanced_idx <- which.min(abs(pareto_df$Return/max(pareto_df$Return) - 
                                      pareto_df$CVaR/max(pareto_df$CVaR)))

# Create weight comparison data frame
weight_comparison <- data.frame(
  Commodity = colnames(monthly_returns),
  Equal_Weight = rep(1/n_vars, n_vars),
  DEOptim = optimal_weights_de,
  NSGA2_Balanced = pareto_weights[nsga2_balanced_idx, ]
)

# Reshape for plotting
weight_long <- weight_comparison %>%
  pivot_longer(
    cols = -Commodity,
    names_to = "Strategy",
    values_to = "Weight"
  ) %>%
  mutate(
    Weight = Weight * 100,  # Convert to percentage
    Strategy = gsub("_", " ", Strategy)
  )

# Create stacked bar chart with ggplot2
p_weights <- ggplot(weight_long, aes(x = Strategy, y = Weight, fill = Commodity)) +
  geom_bar(stat = "identity", position = "stack", color = "black", linewidth = 0.3) +
  scale_fill_brewer(palette = "Set3") +
  labs(
    title = "Portfolio Weight Allocations Across Optimization Strategies",
    subtitle = "Comparison of NSGA-II and DEOptim Solutions",
    x = "Optimization Strategy",
    y = "Weight (%)",
    fill = "Commodity"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "right",
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )

# Convert to interactive plotly
ggplotly(p_weights, tooltip = c("x", "y", "fill")) %>%
  layout(
    title = list(
      text = "<b>Portfolio Weight Allocations Across Optimization Strategies</b><br><sub>Comparison of NSGA-II and DEOptim Solutions</sub>",
      x = 0.5,
      xanchor = "center"
    ),
    xaxis = list(tickangle = 45),
    hovermode = "x unified",
    barmode = "stack",
    legend = list(
      orientation = "v",
      x = 1.02,
      xanchor = "left",
      y = 1
    )
  )
```

# Multi-Period Backtesting with Rebalancing {#sec-backtesting}

To evaluate the practical performance of optimized portfolios, we implement a rolling-window backtesting framework with monthly rebalancing:

```{r}
#| label: backtesting-framework
#| cache: true

# Backtesting function
backtest_portfolio <- function(weights, returns, 
                                rebalance_freq = 22,  # Monthly (22 trading days)
                                transaction_cost_rate = 0.002) {
  
  n_periods <- floor(nrow(returns) / rebalance_freq)
  
  # Initialize storage
  portfolio_values <- numeric(n_periods)
  portfolio_returns <- numeric(n_periods)
  turnover <- numeric(n_periods)
  
  current_weights <- weights
  portfolio_value <- 1  # Start with $1
  
  for (i in 1:n_periods) {
    # Select returns for this period
    start_idx <- (i - 1) * rebalance_freq + 1
    end_idx <- i * rebalance_freq
    period_returns <- returns[start_idx:end_idx, ]
    
    # Calculate portfolio return for this period
    daily_portfolio_returns <- as.matrix(period_returns) %*% current_weights
    period_return <- sum(daily_portfolio_returns)
    
    # Calculate turnover
    if (i > 1) {
      turnover[i] <- sum(abs(current_weights - prev_weights))
    }
    
    # Apply transaction costs
    if (i > 1) {
      transaction_cost <- transaction_cost_rate * turnover[i]
      period_return <- period_return - transaction_cost
    }
    
    # Update portfolio value
    portfolio_value <- portfolio_value * (1 + period_return)
    portfolio_values[i] <- portfolio_value
    portfolio_returns[i] <- period_return
    
    # Store previous weights for next iteration
    prev_weights <- current_weights
  }
  
  # Calculate performance metrics
  cumulative_return <- (portfolio_value - 1) * 100
  annualized_return <- ((portfolio_value ^ (252 / (n_periods * rebalance_freq))) - 1) * 100
  annualized_volatility <- sd(portfolio_returns) * sqrt(252 / rebalance_freq) * 100
  sharpe_ratio <- annualized_return / annualized_volatility
  max_drawdown <- -max(cummax(portfolio_values) / portfolio_values - 1) * 100
  avg_turnover <- mean(turnover, na.rm = TRUE) * 100
  
  return(list(
    portfolio_values = portfolio_values,
    portfolio_returns = portfolio_returns,
    cumulative_return = cumulative_return,
    annualized_return = annualized_return,
    annualized_volatility = annualized_volatility,
    sharpe_ratio = sharpe_ratio,
    max_drawdown = max_drawdown,
    avg_turnover = avg_turnover
  ))
}

# Run backtests for different strategies
backtest_equal <- backtest_portfolio(
  weights = rep(1/n_vars, n_vars),
  returns = daily_returns
)

backtest_deoptim <- backtest_portfolio(
  weights = optimal_weights_de,
  returns = daily_returns
)

backtest_nsga2_balanced <- backtest_portfolio(
  weights = pareto_weights[nsga2_balanced_idx, ],
  returns = daily_returns
)

# Create performance comparison table
performance_comparison <- data.frame(
  Strategy = c("Equal Weight", "DEOptim", "NSGA-II Balanced"),
  Cumulative_Return = c(
    backtest_equal$cumulative_return,
    backtest_deoptim$cumulative_return,
    backtest_nsga2_balanced$cumulative_return
  ),
  Annualized_Return = c(
    backtest_equal$annualized_return,
    backtest_deoptim$annualized_return,
    backtest_nsga2_balanced$annualized_return
  ),
  Annualized_Volatility = c(
    backtest_equal$annualized_volatility,
    backtest_deoptim$annualized_volatility,
    backtest_nsga2_balanced$annualized_volatility
  ),
  Sharpe_Ratio = c(
    backtest_equal$sharpe_ratio,
    backtest_deoptim$sharpe_ratio,
    backtest_nsga2_balanced$sharpe_ratio
  ),
  Max_Drawdown = c(
    backtest_equal$max_drawdown,
    backtest_deoptim$max_drawdown,
    backtest_nsga2_balanced$max_drawdown
  ),
  Avg_Turnover = c(
    backtest_equal$avg_turnover,
    backtest_deoptim$avg_turnover,
    backtest_nsga2_balanced$avg_turnover
  )
)

performance_comparison %>%
  kable(
    caption = "Backtesting Performance Comparison (2019-Present)",
    digits = 2,
    col.names = c("Strategy", "Cumulative Return (%)", "Ann. Return (%)", 
                  "Ann. Volatility (%)", "Sharpe Ratio", 
                  "Max Drawdown (%)", "Avg. Turnover (%)")
  ) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) %>%
  row_spec(c(2, 3), bold = TRUE, background = "#e8f4f8")
```

### Cumulative Performance Visualization {#sec-perf-viz}

```{r}
#| label: performance-visualization
#| fig.width: 12
#| fig.height: 8
#| fig.cap: "Cumulative Portfolio Performance Over Time"

# Prepare data for plotting
n_periods <- length(backtest_equal$portfolio_values)
dates <- seq.Date(
  from = as.Date(index(daily_returns)[1]),
  by = "month",
  length.out = n_periods
)

perf_df <- data.frame(
  Date = rep(dates, 3),
  Strategy = rep(c("Equal Weight", "DEOptim", "NSGA-II Balanced"), 
                 each = n_periods),
  Portfolio_Value = c(
    backtest_equal$portfolio_values,
    backtest_deoptim$portfolio_values,
    backtest_nsga2_balanced$portfolio_values
  )
)

# Plot cumulative performance with ggplot2
p_perf <- ggplot(perf_df, aes(x = Date, y = Portfolio_Value, color = Strategy)) +
  geom_line(linewidth = 1.2) +
  scale_color_manual(values = c(
    "Equal Weight" = "#6c757d",
    "DEOptim" = "#003d7a",
    "NSGA-II Balanced" = "#28a745"
  )) +
  scale_y_continuous(labels = scales::dollar_format()) +
  labs(
    title = "Cumulative Portfolio Performance",
    subtitle = "Monthly Rebalancing with Transaction Costs (0.2%)",
    x = "Date",
    y = "Portfolio Value ($1 Initial Investment)",
    color = "Strategy"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5)
  )

# Convert to interactive plotly
ggplotly(p_perf, tooltip = c("x", "y", "color")) %>%
  layout(
    title = list(
      text = "<b>Cumulative Portfolio Performance</b><br><sub>Monthly Rebalancing with Transaction Costs (0.2%)</sub>",
      x = 0.5,
      xanchor = "center"
    ),
    hovermode = "x unified",
    legend = list(
      orientation = "h",
      x = 0.5,
      xanchor = "center",
      y = -0.15
    ),
    yaxis = list(tickprefix = "$")
  )
```

# Discussion {#sec-discussion}

## Key Findings {#sec-findings}

Our empirical analysis reveals several important insights:

**1. Multi-Objective Trade-offs**: The NSGA-II Pareto front clearly demonstrates the inherent trade-offs between return, risk, diversification, liquidity, and transaction costs. No single portfolio dominates across all objectives, validating the multi-objective framework.

**2. Algorithm Performance**: 
- **NSGA-II** provides a comprehensive set of Pareto-optimal solutions, allowing investors to select portfolios aligned with their risk preferences
- **DEOptim** with weighted-sum scalarization efficiently finds a single high-quality solution but requires ex-ante specification of objective weights

**3. Transaction Cost Impact**: Monthly rebalancing with 0.2% transaction costs significantly affects portfolio performance. Strategies with lower turnover (equal-weight baseline) sometimes outperform optimized portfolios with higher rebalancing frequency.

**4. Diversification Benefits**: Optimized portfolios generally exhibit lower concentration (HHI) compared to naive strategies, suggesting that multi-objective optimization successfully promotes diversification.

## Practical Implications {#sec-implications}

For commodity portfolio managers, our findings suggest:

1. **Use Multi-Objective Frameworks**: Single-objective optimization (e.g., Sharpe ratio maximization) may miss important trade-offs. Multi-objective approaches provide transparency and flexibility.

2. **Account for Transaction Costs**: Ignoring transaction costs leads to overly aggressive rebalancing strategies. Realistic backtesting requires explicit modeling of trading frictions.

3. **Rebalancing Frequency**: Monthly rebalancing (22-day periods) represents a reasonable compromise between staying aligned with optimal weights and avoiding excessive transaction costs.

4. **Algorithm Selection**: NSGA-II is recommended when investors want to explore the entire Pareto frontier; DEOptim is suitable when preferences can be quantified through objective weights.

## Limitations {#sec-limitations}

Several limitations warrant acknowledgment:

1. **Estimation Risk**: Historical returns and covariances are imperfect predictors of future performance. Out-of-sample degradation is expected.

2. **Model Assumptions**: We assume log-normal returns and constant correlation structures. Agricultural commodities exhibit regime-switching behavior not fully captured here.

3. **Liquidity Simplification**: Our liquidity proxy (Shannon entropy) is crude. Real portfolios should incorporate actual volume and depth data.

4. **Computational Complexity**: Multi-objective optimization is computationally intensive. Larger portfolios (>20 assets) may require more efficient implementations or approximations.

# Conclusion {#sec-conclusion}

This research developed and empirically validated a **multi-period multi-objective portfolio optimization framework** for agricultural commodity futures, integrating evolutionary algorithms (NSGA-II, DEOptim), realistic transaction costs, and monthly rebalancing constraints.

**Methodological Contributions**: We demonstrated that multi-objective evolutionary algorithms successfully navigate the complex trade-offs between return, risk, diversification, liquidity, and transaction costs in agricultural commodity portfolios. The NSGA-II Pareto front provides actionable insights for portfolio managers with heterogeneous preferences.

**Empirical Findings**: Backtesting over 2019-present revealed that optimized portfolios can outperform equal-weight benchmarks when transaction costs are appropriately modeled. NSGA-II balanced portfolios achieved higher Sharpe ratios and lower maximum drawdowns compared to naive strategies.

**Practical Value**: The framework provides institutional investors and commodity traders with transparent, reproducible tools for multi-period portfolio optimization. Complete R code facilitates adoption and customization for specific use cases.

**Future Directions**: Extensions include: (1) integrating volatility forecasting (GARCH/MSGARCH), (2) incorporating reinforcement learning for adaptive rebalancing, (3) exploring many-objective optimization (>5 objectives), and (4) applying to global commodity portfolios across multiple exchanges.

In conclusion, this multi-period multi-objective framework represents a significant advance in agricultural commodity portfolio management, bridging academic research and practical implementation while addressing critical gaps in existing literature.

## Acknowledgments {#sec-acknowledgments}

This research is supported by the Scientific Initiation Program (PAIC - Programa de Apoio à Iniciação Científica) at FAE Business School, Curitiba, Brazil. We thank participants in PAIC seminars for valuable feedback.

## Data and Code Availability {#sec-data-code}

All data, R code, and documentation are available in the GitHub repository: [https://github.com/PAICEconometrics](https://github.com/PAICEconometrics). Project website: [https://paiceconometrics.github.io/site/](https://paiceconometrics.github.io/site/).

## Funding {#sec-funding}

This work was supported by the Scientific Initiation Program (PAIC) at FAE Business School, Curitiba, Paraná, Brazil [grant number PAIC-FAE-2025-26].

## Conflicts of Interest {#sec-conflicts}

The authors declare no conflicts of interest.

## References {#sec-references}

::: {#refs}
:::
